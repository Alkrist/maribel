#version 430 core

layout (local_size_x = 2, local_size_y = 2) in;

layout (binding = 0, rgba16f) uniform writeonly image2D defferedSceneImage;

layout (binding = 2, rgba16f) uniform readonly image2DMS albedoSampler;
layout (binding = 3, rgba32f) uniform readonly image2DMS worldPositionSampler;
layout (binding = 4, rgba16f) uniform readonly image2DMS normalSampler;
layout (binding = 5, rgba16f) uniform readonly image2DMS specular_emission_diffuse_ssao_bloom_Sampler;
layout (binding = 6, r16f) uniform readonly image2D ssaoBlurImage;
layout (binding = 7, r8) uniform readonly image2D sampleCoverageMask;

struct PointLight {
	vec4 position;
	vec4 color;
	float intensity;
	float radius;
};

layout(std430, binding = 1) restrict buffer lightSSBO
{
	PointLight pointLight[];
};

struct AmbientLight
{
	vec3 color;
	float intensity;
};

struct DirectionLight
{
    vec3 color;
    vec3 direction;
    float intensity;
};

// MSAA uniforms
uniform uint numSamples;

// SSAO uniforms
uniform uint ssaoEnable;

// Ambient and direction lights
uniform uint directionLightEnable;
uniform DirectionLight directionLight;
uniform uint ambientLightEnable;
uniform AmbientLight ambientLight;

float calculateFogFactor(float dist, float sightRangeFactor) {
	return smoothstep(0, 1, -0.0002 / sightRangeFactor * (dist - (zFar) / 10 * sightRangeFactor) + 1);
}

vec3 diffuse(vec3 albedo, vec3 normal, vec3 toLightDirection, vec3 lightColor, float intensity){
	float diffuseFactor = max(dot(normal, toLightDirection), 0.0);
	return albedo * lightColor * diffuseFactor * intensity;
}

vec3 specular(vec3 normal, vec3 position, vec3 toLightDir, vec3 lightColor, float reflectance, float emission, float intensity){
	vec3 cameraDirection = normalize(-position);
	vec3 fromLightDir = -toLightDir;
	vec3 reflectedLight = normalize(reflect(fromLightDir, normal));
	float specularFactor = max(dot(cameraDirection, reflectedLight), 0.0);
	specularFactor = pow(specularFactor, emission);
	return intensity  * specularFactor * reflectance * lightColor;
}

vec3 calculatePointLight(vec3 albedo, vec3 position, vec3 normal, PointLight light, float reflectance, float emission){
	vec3 lightDirection = light.position.xyz - position;
	vec3 toLightDir  = normalize(lightDirection);

	vec3 diffuse = diffuse(albedo, normal, toLightDir, light.color.rgb, light.intensity);
	vec3 specular = specular(normal, position, toLightDir,light.color.rgb, reflectance, emission, light.intensity);

	// Attenuation
	float distance = length(light.position.xyz - position);
	float attenuation = 1.0 / (1.0 + (distance / light.radius));

	diffuse *= attenuation;
	specular *= attenuation;

	return diffuse + specular;
}

vec3 calculateDirectionLight(vec3 albedo, vec3 position, vec3 normal, DirectionLight light, float reflectance, float emission){
	vec3 diffuse = diffuse(albedo, normal, normalize(light.direction), light.color, light.intensity);
	vec3 specular = specular(normal, position, normalize(light.direction), light.color, reflectance, emission, light.intensity);

	return diffuse + specular;
}

vec3 calculateAmbientLight(AmbientLight light, float emission) {
    return light.color * light.intensity * emission;
}

void main(void) {
	ivec2 computeCoord = ivec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y);

	vec3 finalColor = vec3(0);
	vec3 albedo = vec3(0);
	vec3 position = vec3(0);
	vec4 normal = vec4(0);
	vec4 specular_emission_diffuse_ssao_bloom = vec4(0);

	// Check if current fragment is in aliased region, if yes, approximate it's value by samples (MSAA)
	if(imageLoad(sampleCoverageMask, computeCoord).r == 1.0){
		for (int i=0; i<numSamples; i++){

			albedo = imageLoad(albedoSampler, computeCoord,i).rgb;
			normal = imageLoad(normalSampler, computeCoord,i).rbga;

			// Prevent lighting atmosphere
			if (normal.a != 0){

				position = imageLoad(worldPositionSampler, computeCoord,i).rgb;
				specular_emission_diffuse_ssao_bloom = imageLoad(specular_emission_diffuse_ssao_bloom_Sampler, computeCoord,i).rgba;

				int diffuseEnable = int(specular_emission_diffuse_ssao_bloom.z/10.0);
				float ssao = specular_emission_diffuse_ssao_bloom.z - (diffuseEnable * 10);

				// Calculate SSAO factor
				if (ssao == 1 && ssaoEnable == 1){
					ssao = imageLoad(ssaoBlurImage, computeCoord).r;
				}else{
					ssao = 1;
				}

				if(ambientLightEnable == 1){
					finalColor += calculateAmbientLight(ambientLight, specular_emission_diffuse_ssao_bloom.g);
				}

				if(directionLightEnable == 1){
					finalColor += calculateDirectionLight(albedo,
							position,
							normalize(normal.xyz),
							directionLight,
							specular_emission_diffuse_ssao_bloom.r,
							specular_emission_diffuse_ssao_bloom.g);
				}

				// TODO: calculate shadow

				for (int i = 0; i < pointLight.length(); ++i){
					PointLight light = pointLight[i];

					// Apply point lights
					finalColor += calculatePointLight(
							albedo,
							position,
							normalize(normal.xyz),
							light,
							specular_emission_diffuse_ssao_bloom.r,
							specular_emission_diffuse_ssao_bloom.g);
				}
				finalColor *= ssao;
			}else{
				finalColor = albedo;
			}
		}
	}else{

		albedo = imageLoad(albedoSampler, computeCoord,0).rgb;
		normal = imageLoad(normalSampler, computeCoord,0).rbga;

		// Prevent lighting atmosphere
		if (normal.a != 0){

			position = imageLoad(worldPositionSampler, computeCoord,0).rgb;
			specular_emission_diffuse_ssao_bloom = imageLoad(specular_emission_diffuse_ssao_bloom_Sampler, computeCoord,0).rgba;

			int diffuseEnable = int(specular_emission_diffuse_ssao_bloom.z/10.0);
			float ssao = specular_emission_diffuse_ssao_bloom.z - (diffuseEnable * 10);

			// Calculate SSAO factor
			if (ssao == 1 && ssaoEnable == 1){
				ssao = imageLoad(ssaoBlurImage, computeCoord).r;
			}else{
				ssao = 1;
			}

			if(ambientLightEnable == 1){
				finalColor += calculateAmbientLight(ambientLight, specular_emission_diffuse_ssao_bloom.g);
			}

			if(directionLightEnable == 1){
				finalColor += calculateDirectionLight(albedo,
						position,
						normalize(normal.xyz),
						directionLight,
						specular_emission_diffuse_ssao_bloom.r,
						specular_emission_diffuse_ssao_bloom.g);
			}
			// TODO: calculate shadow

			for (int i = 0; i < pointLight.length(); ++i){
				PointLight light = pointLight[i];

				// Apply point lights
				finalColor += calculatePointLight(
						albedo,
						position,
						normalize(normal.xyz),
						light,
						specular_emission_diffuse_ssao_bloom.r,
						specular_emission_diffuse_ssao_bloom.g);
			}
			finalColor *= ssao;

		}else{
			finalColor = albedo;
		}
	}

	// TODO: apply fog
	// Save final result to output image
	imageStore(defferedSceneImage, computeCoord, vec4(finalColor, 1.0));
}
