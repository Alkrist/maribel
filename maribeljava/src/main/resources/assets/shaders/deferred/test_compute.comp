#version 430 core

layout (local_size_x = 2, local_size_y = 2) in;

layout (binding = 0, rgba16f) uniform writeonly image2D defferedSceneImage;

layout (binding = 2, rgba16f) uniform readonly image2DMS albedoSampler;
layout (binding = 3, rgba32f) uniform readonly image2DMS worldPositionSampler;
layout (binding = 4, rgba16f) uniform readonly image2DMS normalSampler;
layout (binding = 5, rgba16f) uniform readonly image2DMS specular_emission_diffuse_ssao_bloom_Sampler;

struct PointLight {
	vec4 position;
	vec4 color;
	float intensity;
	float radius;
};

struct Cluster {
	vec4 minPoint;
	vec4 maxPoint;
	uint count;
	uint lightIndices[100];
};

layout(std430, binding = 1) restrict buffer clusterSSBO
{
	Cluster clusters[];
};

layout(std430, binding = 2) restrict buffer lightSSBO
{
	PointLight pointLight[];
};

uniform float zNear;
uniform float zFar;
uniform uvec3 gridSize;
uniform uvec2 screenDimensions;

uniform mat4 viewMatrix;
uniform vec3 cameraPosition;

vec3 diffuse(vec3 albedo, vec3 normal, vec3 toLightDirection, vec3 lightColor,
		float lightIntensity) {
	float diffuseFactor = max(dot(normal, toLightDirection), 0.0);
	return albedo * lightColor * diffuseFactor * lightIntensity;
}

vec3 specular(vec3 normal, vec3 position, vec3 toLightDir, vec3 lightColor,
		float reflectance, float emission, float lightIntensity) {
	vec3 d = cameraPosition;
	vec3 viewPosition = (viewMatrix * vec4(position, 1.0)).xyz;
	vec3 cameraDirection = normalize(-viewPosition);
	vec3 fromLightDir = -toLightDir;
	vec3 reflectedLight = normalize(reflect(fromLightDir, normal));
	float specularFactor = max(dot(cameraDirection, reflectedLight), 0.0);
	specularFactor = pow(specularFactor, emission);
	return lightIntensity * specularFactor * reflectance * lightColor;
}

vec3 calculateLight(vec3 albedo, vec3 position, vec3 normal, PointLight light,
		float reflectance, float emission) {
	vec3 lightDirection = light.position.xyz - position;
	vec3 toLightDir = normalize(lightDirection);

	vec3 diffuse = diffuse(albedo, normal, toLightDir, light.color.rgb,
			light.intensity);
	vec3 specular = specular(normal, position, toLightDir, light.color.rgb,
			reflectance, emission, light.intensity);

	// Attenuation
	float distance = length(light.position.xyz - position);
	float attenuation = 1.0 / (1.0 + (distance / light.radius));

	diffuse *= attenuation;
	specular *= attenuation;

	// To test, I set lighting to 0 if fragment is beyond radius
	if(distance > light.radius){
		return vec3(0);
	}
	return diffuse + specular;
}

void main(void) {
	ivec2 computeCoord = ivec2(gl_GlobalInvocationID.x,
			gl_GlobalInvocationID.y);

	vec3 finalColor = vec3(0);
	vec3 albedo = vec3(0);
	vec3 position = vec3(0);
	vec4 normal = vec4(0);
	vec4 specular_emission_diffuse_ssao_bloom = vec4(0);
	vec4 depth = vec4(0);

	albedo = imageLoad(albedoSampler, computeCoord, 0).rgb;
	normal = imageLoad(normalSampler, computeCoord, 0).rbga;

	position = imageLoad(worldPositionSampler, computeCoord, 0).rgb;
	specular_emission_diffuse_ssao_bloom = imageLoad(
			specular_emission_diffuse_ssao_bloom_Sampler, computeCoord, 0).rgba;

	uint zTile = uint(
			(log(abs(vec3(viewMatrix * vec4(position, 1.0)).z) / zNear)
					* gridSize.z) / log(zFar / zNear));
	vec2 tileSize = screenDimensions / gridSize.xy;

	uvec3 tile = uvec3(computeCoord.xy / tileSize, zTile);
	uint tileIndex = tile.x + (tile.y * gridSize.x)
			+ (tile.z * gridSize.x * gridSize.y);

	uint lightCount = clusters[tileIndex].count;

	finalColor = albedo * 0.02;
	for (int i = 0; i < lightCount; ++i) {
		uint lightIndex = clusters[tileIndex].lightIndices[i];
		PointLight light = pointLight[lightIndex];

		// Lighting
		finalColor += calculateLight(albedo, position, normalize(normal.xyz),
				light, specular_emission_diffuse_ssao_bloom.r,
				specular_emission_diffuse_ssao_bloom.g);


	}

	imageStore(defferedSceneImage, computeCoord, vec4(finalColor, 1.0));
}
