#version 430 core

layout (local_size_x = 2, local_size_y = 2) in;

layout (binding = 0, rgba16f) uniform writeonly image2D defferedSceneImage;

layout (binding = 2, rgba16f) uniform readonly image2DMS albedoSampler;
layout (binding = 3, rgba32f) uniform readonly image2DMS worldPositionSampler;
layout (binding = 4, rgba16f) uniform readonly image2DMS normalSampler;
layout (binding = 5, rgba16f) uniform readonly image2DMS specular_emission_diffuse_ssao_bloom_Sampler;
layout (binding = 6, r16f) uniform readonly image2D ssaoBlurImage;

const int SHADOW_MAP_RESOLUTION = 4096;
const int SHADOW_VARIANCE_HIGH_QUALITY[5] = int[5](2,2,4,4,11);
const int SHADOW_VARIANCE_MEDIUM_QUALITY[5] = int[5](1,1,2,2,7);
const int SHADOW_VARIANCE_LOW_QUALITY[5] = int[5](1,1,2,2,5);
const int SHADOW_VARIANCE_VERY_LOW_QUALITY[5] = int[5](1,1,1,1,1);
const float ZFAR = 10000;


struct Attenuation
{
    float constant;
    float linear;
    float exponent;
};

struct DirectionLight
{
    vec3 color;
    vec3 direction;
    float intensity;
};

struct PointLight
{
    vec3 position;
    vec3 color;
    float intensity;
    Attenuation att;
};

struct SpotLight
{
	PointLight pl;
	vec3 conedir;
	float cutoff;
};


uniform DirectionLight dirLight;
uniform PointLight pointLight;
uniform SpotLight spotLight;

uniform sampler2DArray pssm;
const int shadowsQuality = 2;
uniform mat4 projViewMatrices[5];
uniform float splitDistances[5];
uniform mat4 viewMatrix;


float calculateFogFactor(float dist, float sightRangeFactor) {
	return smoothstep(0, 1, -0.0002 / sightRangeFactor * (dist - (ZFAR) / 10 * sightRangeFactor) + 1);
}


vec3 calculateLightColor(vec3 normal, vec3 position, vec3 to_light_dir, vec3 lightColor, float light_intensity, float emission, float reflectance){

	vec3 diffuseColor = vec3(0);
	vec3 specularColor = vec3(0);

	//diffuse
	float diffuseFactor = max(dot(normal, to_light_dir), 0.0);
	diffuseColor =  lightColor * diffuseFactor * light_intensity;
	diffuseColor = max(diffuseColor, 0.02); //TODO: can remove this, if total darkness is OK

	//specular
	vec3 camera_direction = normalize(-position);
	vec3 from_light_dir = -to_light_dir;
	vec3 reflected_light = normalize(reflect(from_light_dir, normal));
	float specularFactor = max(dot(camera_direction, reflected_light), 0.0);
	specularFactor = pow(specularFactor, emission);
	specularColor = light_intensity  * specularFactor * reflectance * lightColor;

	//diffuse + specular
	return (diffuseColor + specularColor);
}

vec3 calculateDirectionalLight(vec3 position, vec3 normal, DirectionLight light, float reflectance, float emission){
	return calculateLightColor(normal, position, normalize(light.direction),
			light.color, light.intensity, emission, reflectance);
}


vec3 calculatePointLight(vec3 position, vec3 normal, PointLight light, float reflectance, float emission){
	vec3 light_direction = light.position - position;
	vec3 to_light_dir  = normalize(light_direction);
	vec3 lightColor = calculateLightColor(normal, position, to_light_dir,
			light.color, light.intensity, emission, reflectance);

	float distance = length(light_direction);
	float attenuationInv = light.att.constant + light.att.linear * distance +
	    light.att.exponent * distance * distance;

	return lightColor / attenuationInv;
}

vec3 calculateSpotLight(vec3 position, vec3 normal, SpotLight light, float reflectance, float emission){
	 vec3 light_direction = light.pl.position - position;
	 vec3 to_light_dir  = normalize(light_direction);
	 vec3 from_light_dir  = -to_light_dir;
	 float spot_alfa = dot(from_light_dir, normalize(light.conedir));

	 vec3 lightColor = vec3(0);
	 if (spot_alfa > light.cutoff){
		 lightColor = calculatePointLight(position, normal, light.pl, reflectance, emission);
		 lightColor *= (1.0 - (1.0 - spot_alfa)/(1.0 - light.cutoff));
	 }

	 return lightColor;
}

float varianceShadow(vec3 projCoords, int split, int kernels){

	float shadowFactor = 1.0;
	float texelSize = 1.0/ SHADOW_MAP_RESOLUTION;
	float currentDepth = projCoords.z;
	float reduceFactor = 1/ pow(kernels*2+1,2);

	for (int i=-kernels; i<=kernels; i++){
		for (int j=-kernels; j<=kernels; j++){
			float shadowMapDepth = texture(pssm, vec3(projCoords.xy,split) + vec3(i,j,0) * texelSize).r;
			if (currentDepth > shadowMapDepth)
				shadowFactor -= reduceFactor;
		}
	}

	return max(0.1,shadowFactor);
}



float applyShadowMapping(vec3 worldPos)
{
	float shadowFactor = 1;
	float terrainShadow = 1;
	vec3 projCoords = vec3(0,0,0);
	float linDepth = abs((viewMatrix * vec4(worldPos,1)).z/ZFAR); //Can add division by ZFAR
	int[5] variance_shadows_kernels = int[5](0,0,0,0,0);

	switch(shadowsQuality)
	{
		case 3: variance_shadows_kernels = SHADOW_VARIANCE_HIGH_QUALITY; break;
		case 2: variance_shadows_kernels = SHADOW_VARIANCE_MEDIUM_QUALITY; break;
		case 1: variance_shadows_kernels = SHADOW_VARIANCE_LOW_QUALITY; break;
		case 0: variance_shadows_kernels = SHADOW_VARIANCE_VERY_LOW_QUALITY; break;
	}

	//TODO: FUCKING DO SOMETHING WITH LAGGY TERRAIN SHADOW!!!
	//Perhaps, move it down, so it's rendered only if linear depth is too big. But study it first.

	//vec4 lightSpacePos = projViewMatrices[4] * vec4(worldPos,1.0);
	//projCoords = lightSpacePos.xyz * 0.5 + 0.5;
	//terrainShadow = varianceShadow(projCoords,4,variance_shadows_kernels[4]);

	if (linDepth <= splitDistances[0]){
		vec4 lightSpacePos = projViewMatrices[0] * vec4(worldPos,1.0);
		projCoords = lightSpacePos.xyz * 0.5 + 0.5;
		shadowFactor = varianceShadow(projCoords,0,variance_shadows_kernels[0]);

		lightSpacePos = projViewMatrices[1] * vec4(worldPos,1.0);
		projCoords = lightSpacePos.xyz * 0.5 + 0.5;
		shadowFactor = min(shadowFactor,varianceShadow(projCoords,1,variance_shadows_kernels[1]));
	}
	else if (linDepth <= splitDistances[1]){
		vec4 lightSpacePos = projViewMatrices[1] * vec4(worldPos,1.0);
		projCoords = lightSpacePos.xyz * 0.5 + 0.5;
		shadowFactor = varianceShadow(projCoords,1,variance_shadows_kernels[1]);

		lightSpacePos = projViewMatrices[2] * vec4(worldPos,1.0);
		projCoords = lightSpacePos.xyz * 0.5 + 0.5;
		shadowFactor = min(shadowFactor,varianceShadow(projCoords,2,variance_shadows_kernels[2]));
	}
	else if (linDepth <= splitDistances[2]){
		vec4 lightSpacePos = projViewMatrices[2] * vec4(worldPos,1.0);
		projCoords = lightSpacePos.xyz * 0.5 + 0.5;
		shadowFactor = varianceShadow(projCoords,2,variance_shadows_kernels[2]);
	}
	else if (linDepth <= splitDistances[3]){

		vec4 lightSpacePos = projViewMatrices[3] * vec4(worldPos,1.0);
		projCoords = lightSpacePos.xyz * 0.5 + 0.5;
		shadowFactor = varianceShadow(projCoords,3,variance_shadows_kernels[3]);
	}

	return shadowFactor;
	//return min(terrainShadow, shadowFactor);
}

void main(void){

	ivec2 computeCoord = ivec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y);

	vec3 finalColor = vec3(0);
	vec3 albedo = vec3(0);
	vec3 position = vec3(0);
	vec4 normal = vec4(0);
	vec4 specular_emission_diffuse_ssao_bloom = vec4(0);


	albedo = imageLoad(albedoSampler, computeCoord,0).rgb;
	normal = imageLoad(normalSampler, computeCoord,0).rbga;
	if (normal.a != 0){
		position = imageLoad(worldPositionSampler, computeCoord,0).rgb;
		specular_emission_diffuse_ssao_bloom = imageLoad(specular_emission_diffuse_ssao_bloom_Sampler, computeCoord,0).rgba;

		finalColor = calculateDirectionalLight(position,
				normalize(normal.xyz),
				dirLight,
				specular_emission_diffuse_ssao_bloom.r,
				specular_emission_diffuse_ssao_bloom.g);

		finalColor += calculatePointLight(position,
				normalize(normal.xyz),
				pointLight,
				specular_emission_diffuse_ssao_bloom.r,
				specular_emission_diffuse_ssao_bloom.g);

		finalColor += calculateSpotLight(position,
				normalize(normal.xyz),
				spotLight,
				specular_emission_diffuse_ssao_bloom.r,
				specular_emission_diffuse_ssao_bloom.g);

		finalColor = finalColor * albedo;
		finalColor = finalColor * applyShadowMapping(position);
	}
	else{
		finalColor = albedo;
	}

	imageStore(defferedSceneImage, computeCoord, vec4(finalColor, 1.0));
}
