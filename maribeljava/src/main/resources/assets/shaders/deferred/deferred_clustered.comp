#version 430 core

layout (local_size_x = 2, local_size_y = 2) in;

layout (binding = 0, rgba16f) uniform writeonly image2D defferedSceneImage;

layout (binding = 2, rgba16f) uniform readonly image2DMS albedoSampler;
layout (binding = 3, rgba32f) uniform readonly image2DMS worldPositionSampler;
layout (binding = 4, rgba16f) uniform readonly image2DMS normalSampler;
layout (binding = 5, rgba16f) uniform readonly image2DMS specular_emission_diffuse_ssao_bloom_Sampler;

uniform sampler2D clusterBuffer;
uniform sampler2D lightBuffer;
uniform vec2 resolution;
uniform vec3 slices;
uniform mat4 viewMatrix;
uniform mat4 projectionMatrix;
uniform vec3 cameraPos;

const int MAX_LIGHTS_PER_CLUSTER = 100;
const int NUM_LIGHTS = 3; //TODO: make it varying maybe?
const float zNear = 0.1;
const float zFar = 10000.0;

struct Light {
  vec3 position;
  float radius;
  vec3 color;
};

float extractFloat(sampler2D texture, int textureWidth, int textureHeight, int index, int component){
	float u = float(index + 1) / float(textureWidth + 1);
	int pixel = component / 4;
	float v = float(pixel + 1) / float(textureHeight + 1);
	vec4 texel = texture(texture, vec2(u, v));
	int pixelComponent = component - pixel * 4;
	if (pixelComponent == 0) {
	        return texel[0];
		} else if (pixelComponent == 1) {
	        return texel[1];
	      } else if (pixelComponent == 2) {
	        return texel[2];
	      } else if (pixelComponent == 3) {
	        return texel[3];
	      }
}

Light unpackLight(int index){
	Light light;
	float u = float(index + 1) / float(NUM_LIGHTS + 1); // number of lights in texture
	vec4 v1 = texture(lightBuffer, vec2(u, 0.3));
	vec4 v2 = texture(lightBuffer, vec2(u, 0.6));

	light.position = v1.xyz;
	light.radius = extractFloat(lightBuffer, NUM_LIGHTS, 2, index, 3);
	light.color = v2.rgb;

	return light;
}

float cubicGaussian(float h) {
      if (h < 1.0) {
        return 0.25 * pow(2.0 - h, 3.0) - pow(1.0 - h, 3.0);
      } else if (h < 2.0) {
        return 0.25 * pow(2.0 - h, 3.0);
      } else {
        return 0.0;
      }
    }

void main(void){

	ivec2 computeCoord = ivec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y);

	vec3 finalColor = vec3(0);
		vec3 albedo = vec3(0);
		vec3 position = vec3(0);
		vec4 normal = vec4(0);
		vec4 specular_emission_diffuse_ssao_bloom = vec4(0);

		albedo = imageLoad(albedoSampler, computeCoord,0).rgb;
		normal = imageLoad(normalSampler, computeCoord,0).rbga;

		position = imageLoad(worldPositionSampler, computeCoord,0).rgb;
		specular_emission_diffuse_ssao_bloom = imageLoad(specular_emission_diffuse_ssao_bloom_Sampler, computeCoord,0).rgba;

		vec4 viewPos = viewMatrix * vec4(position, 1.0);
		vec3 posNonNDC = (projectionMatrix * viewPos).xyz;

		int frustumX = int(computeCoord.x / resolution.x * slices.x);
		int frustumY = int(computeCoord.y / resolution.y * slices.y);
		int frustumZ = int((posNonNDC.z - zNear) / (zFar - zNear) * slices.z);
		int frustumIndex = int(frustumX + frustumY * slices.x + frustumZ * slices.x * slices.y);
		int numFrustums = int(slices.x * slices.y * slices.z);
		int clusterBufferTextureHeight = int(ceil((MAX_LIGHTS_PER_CLUSTER + 1.0) / 4.0));
		float numLightsInfluenceFrustum = extractFloat(clusterBuffer, numFrustums, clusterBufferTextureHeight, frustumIndex, 0);

		vec3 viewDirection = normalize(cameraPos - position);

		for (int i = 1; i < NUM_LIGHTS; ++i){
			if (i > numLightsInfluenceFrustum) {
			   break;
			}

			int lightIndex = int(extractFloat(clusterBuffer, numFrustums, clusterBufferTextureHeight, frustumIndex, i));
			Light light = unpackLight(lightIndex);
			vec3 lightDir = normalize(light.position - position);

			float lightDistance = distance(light.position, position);
			vec3 L = (light.position - position) / lightDistance;

			float lightIntensity = cubicGaussian(2.0 * lightDistance / light.radius);
			float lambertTerm = max(dot(L, normal.xyz), 0.0);
			//finalColor += albedo * lambertTerm  * light.color * vec3(lightIntensity);
			finalColor += vec3(lightIntensity);
		}

		imageStore(defferedSceneImage, computeCoord, vec4(finalColor, 1.0));
}
